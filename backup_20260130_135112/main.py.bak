from fastapi import FastAPI, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from fastapi.staticfiles import StaticFiles
from sqlalchemy.exc import SQLAlchemyError
from contextlib import asynccontextmanager
from dotenv import load_dotenv

from apscheduler.schedulers.asyncio import AsyncIOScheduler

# üî• IMPORTAR SLOWAPI PARA RATE LIMITING
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# üî• Cargar variables de entorno ANTES de importar settings
load_dotenv()

from core.config import settings
from database.init_db import init_db
from exceptions.base import BaseAPIException

# üî• AGREGAR ESTE IMPORT
from tasks.vigencia_cron import iniciar_scheduler

# ==================== LIFESPAN ====================

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manejo del ciclo de vida de la aplicaci√≥n"""
    # ==================== STARTUP ====================
    print("=" * 60)
    print(f"üöÄ Iniciando {settings.APP_NAME}")
    print(f"üì¶ Versi√≥n: {settings.APP_VERSION}")
    print(f"üîß Modo DEBUG: {settings.DEBUG}")
    print(f"üíæ Base de datos: {settings.DB_NAME}")
    print(f"ü§ñ Modelo Groq: {settings.GROQ_MODEL}")
    print(f"üîí Rate Limiting: {settings.RATE_LIMIT_PER_MINUTE}/min (Login: {settings.RATE_LIMIT_LOGIN_PER_MINUTE}/min)")
    print("=" * 60)
    
    # Inicializar base de datos MySQL
    init_db()
    
    # üî• NUEVO: Inicializar MongoDB
    from database.mongodb import init_mongodb
    await init_mongodb()
    print("‚úÖ MongoDB inicializado")
    
    from apscheduler.schedulers.asyncio import AsyncIOScheduler
    scheduler = AsyncIOScheduler()

    async def finalizar_conversaciones_inactivas_job():
        """Job para finalizar conversaciones inactivas cada 10 minutos"""
        from database.database import SessionLocal
        from services.escalamiento_service import EscalamientoService
        import logging
        
        logger = logging.getLogger(__name__)
        db = SessionLocal()
        
        try:
            service = EscalamientoService(db)
            resultado = await service.finalizar_conversaciones_inactivas(timeout_minutos=1)
            logger.info(f"‚úÖ Auto-finalizaci√≥n ejecutada: {resultado}")
            print(f"üßπ Conversaciones finalizadas: MongoDB={resultado['conversaciones_finalizadas_mongo']}, MySQL={resultado['conversaciones_finalizadas_mysql']}")
        except Exception as e:
            logger.error(f"‚ùå Error en auto-finalizaci√≥n: {e}")
            print(f"‚ùå Error en auto-finalizaci√≥n: {e}")
        finally:
            db.close()

    # Programar tarea cada 10 minutos
    scheduler.add_job(
        finalizar_conversaciones_inactivas_job, 
        'interval', 
        minutes=10,
        id='finalizar_conversaciones',
        replace_existing=True
    )
    scheduler.start()
    print("‚úÖ Scheduler iniciado - Auto-finalizaci√≥n de conversaciones cada 10 minutos")

    # üî• AGREGAR AQU√ç el scheduler de vigencias
    scheduler_vigencias = iniciar_scheduler()
    app.state.scheduler_vigencias = scheduler_vigencias
    print("‚úÖ Scheduler de vigencias iniciado")

    # Guardar scheduler en app state
    app.state.scheduler = scheduler

    yield
    
    # ==================== SHUTDOWN ====================
    print("üëã Cerrando aplicaci√≥n...")
    
    # üî• NUEVO: Detener scheduler
    if hasattr(app.state, 'scheduler'):
        app.state.scheduler.shutdown()
        print("‚úÖ Scheduler detenido")
    
    # üî• NUEVO: Detener scheduler de vigencias
    if hasattr(app.state, 'scheduler_vigencias'):
        app.state.scheduler_vigencias.shutdown()
        print("‚úÖ Scheduler de vigencias detenido")
    
    # üî• NUEVO: Cerrar MongoDB
    from database.mongodb import close_mongodb
    await close_mongodb()
    print("‚úÖ MongoDB cerrado")

# ==================== RATE LIMITING ====================

# üî• Configurar rate limiter
limiter = Limiter(key_func=get_remote_address)

# ==================== CREAR APLICACI√ìN ====================

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="API REST para sistema multi-agente de chatbot institucional con IA",
    lifespan=lifespan,
    docs_url="/docs",
    redoc_url="/redoc",
    debug=settings.DEBUG
)

# üî• Agregar rate limiter a la app
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# ‚úÖ Middleware que EXCLUYE OPTIONS del rate limiting
@app.middleware("http")
async def skip_rate_limit_for_options(request: Request, call_next):
    """Saltarse rate limiting para solicitudes OPTIONS"""
    if request.method == "OPTIONS":
        # Marcar para saltarse rate limit
        request.scope["rate_limit_exempt"] = True
    return await call_next(request)


# üî• NUEVO: Iniciar limpieza de sesiones en background
import threading
from utils.background_tasks import cleanup_sessions_periodically

cleanup_thread = threading.Thread(
    target=cleanup_sessions_periodically,
    args=(10,),  # Limpia cada 10 minutos
    daemon=True
)
cleanup_thread.start()
print("üßπ Background task: Limpieza de sesiones iniciada (cada 10 min)")



# ==================== ARCHIVOS EST√ÅTICOS ====================

# Montar archivos est√°ticos (CSS, JS, im√°genes)
try:
    app.mount("/static", StaticFiles(directory="static"), name="static")
    print("‚úÖ Archivos est√°ticos montados en /static")
except Exception as e:
    print(f"‚ö†Ô∏è  Advertencia: No se pudieron montar archivos est√°ticos: {e}")
    print("   Aseg√∫rate de que la carpeta 'static' existe")

# ==================== MIDDLEWARE ====================

# ‚úÖ PRIMERO: Middleware para manejar preflight CORS OPTIONS (ANTES de rate limiting)
@app.middleware("http")
async def cors_options_middleware(request: Request, call_next):
    """Manejar solicitudes OPTIONS de preflight CORS ANTES de rate limiting"""
    if request.method == "OPTIONS":
        origin = request.headers.get("origin", "*")
        headers = {
            "Access-Control-Allow-Origin": origin,
            "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",
            "Access-Control-Allow-Headers": "*",
            "Access-Control-Max-Age": "3600",
        }
        
        # Solo agregar credentials si NO estamos usando wildcard
        if origin != "*":
            headers["Access-Control-Allow-Credentials"] = "true"
        
        return JSONResponse(
            status_code=200,
            content={},
            headers=headers
        )
    return await call_next(request)

# CORS - Configurado din√°micamente seg√∫n el ambiente
cors_origins = settings.CORS_ORIGINS

print(f"‚úÖ CORS Configuration: {cors_origins}")
print(f"‚úÖ ENVIRONMENT: {settings.ENVIRONMENT}")

app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allow_headers=["*"],
    max_age=3600,
)

# üî• Middleware de seguridad - Headers HTTP seguros
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    """Agregar headers de seguridad a TODAS las respuestas"""
    try:
        response = await call_next(request)
    except Exception as e:
        # Si ocurre un error, crear respuesta con headers de seguridad
        response = JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={"error": True, "message": "Error interno del servidor"}
        )
        raise
    
    # Headers de seguridad - SIEMPRE se agregan
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "SAMEORIGIN"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    response.headers["Permissions-Policy"] = "geolocation=(), microphone=(self), camera=(self)"
    
    # Content Security Policy - Protege contra XSS e inyecci√≥n de datos
    # En desarrollo: m√°s permisivo; en producci√≥n: m√°s restrictivo
    if settings.DEBUG:
        csp_policy = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-eval' https://cdn.jsdelivr.net https://unpkg.com https://cdnjs.cloudflare.com; "
            "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com https://cdnjs.cloudflare.com https://fonts.googleapis.com; "
            "img-src 'self' data: https://cdn.jsdelivr.net https://unpkg.com https://cdnjs.cloudflare.com; "
            "font-src 'self' data: https://cdn.jsdelivr.net https://unpkg.com https://cdnjs.cloudflare.com https://fonts.gstatic.com; "
            "connect-src 'self' https://cdn.jsdelivr.net https://unpkg.com https://cdnjs.cloudflare.com; "
            "frame-ancestors 'self'; "
            "base-uri 'self'; "
            "form-action 'self'"
        )
    else:
        csp_policy = (
            "default-src 'self'; "
            "script-src 'self' https://cdnjs.cloudflare.com https://unpkg.com https://cdn.jsdelivr.net; "
            "style-src 'self' https://cdnjs.cloudflare.com https://fonts.googleapis.com https://cdn.jsdelivr.net; "
            "img-src 'self' data: https://cdnjs.cloudflare.com https://unpkg.com https://cdn.jsdelivr.net; "
            "font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com; "
            "connect-src 'self' https://cdnjs.cloudflare.com https://unpkg.com https://cdn.jsdelivr.net; "
            "frame-ancestors 'self'; "
            "base-uri 'self'; "
            "form-action 'self'"
        )
    
    response.headers["Content-Security-Policy"] = csp_policy
    
    # Mitigation para divulgaci√≥n de timestamps Unix
    # Nota: Los timestamps en respuestas JSON son normales e inevitables en APIs REST
    # Las marcas de tiempo no revelan informaci√≥n sensible por s√≠ solas
    # La alerta "Divulgaci√≥n de Marcas de Tiempo" es principalmente informativa
    response.headers["X-Frame-Options"] = "SAMEORIGIN"
    
    # Cache-Control - Headers de cach√©
    # Para archivos est√°ticos: cache largo
    if request.url.path.startswith("/static"):
        response.headers["Cache-Control"] = "public, max-age=31536000, immutable"  # 1 a√±o
    # Para API: no cachear
    elif request.url.path.startswith("/api") or request.url.path.startswith("/openapi"):
        response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate, private"
    # Por defecto: cache corto
    else:
        response.headers["Cache-Control"] = "public, max-age=3600"  # 1 hora
    
    return response


# ==================== EXCEPTION HANDLERS ====================

@app.exception_handler(BaseAPIException)
async def base_exception_handler(request: Request, exc: BaseAPIException):
    """Manejo de excepciones personalizadas"""
    response = JSONResponse(
        status_code=exc.status_code,
        content={
            "error": True,
            "message": exc.detail,
            "path": str(request.url)
        }
    )
    # Agregar headers de seguridad
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "SAMEORIGIN"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    return response

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Manejo de errores de validaci√≥n de Pydantic"""
    errors = []
    for error in exc.errors():
        errors.append({
            "field": " -> ".join(str(loc) for loc in error["loc"]),
            "message": error["msg"],
            "type": error["type"]
        })
    
    response = JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": True,
            "message": "Error de validaci√≥n",
            "details": errors
        }
    )
    # Agregar headers de seguridad
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "SAMEORIGIN"
    return response

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
    """Manejo de errores de base de datos"""
    response = JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": True,
            "message": "Error en la base de datos",
            "details": str(exc) if settings.DEBUG else "Contacte al administrador"
        }
    )
    # Agregar headers de seguridad
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "SAMEORIGIN"
    return response

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """Manejo de errores generales"""
    response = JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": True,
            "message": "Error interno del servidor",
            "details": str(exc) if settings.DEBUG else "Contacte al administrador"
        }
    )
    # Agregar headers de seguridad
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "SAMEORIGIN"
    return response

# ==================== ROUTERS ====================

# Importar routers
from routers import (
    usuario_router,
    departamento_router,
    rol_router,
    usuario_agente_router,
    departamento_agente_router,
    categoria_router,
    unidad_contenido_router,
    metrica_diaria_agente_router,
    metrica_contenido_router,
    agente_virtual_router,
    visitante_anonimo_router,
    conversacion_sync_router,
    chat_router,
    chat_auto_router,
    agentes_router,
    embeddings_router,
    persona_router,
    widget_router,
    usuario_rol_router,
    aseguramiento_router,
    escalamiento_router,
    websocket_router,
    conversation_router,
    groq_router
)

# Incluir routers de API con prefix /api/v1
app.include_router(usuario_router.router, prefix="/api/v1")
app.include_router(departamento_router.router, prefix="/api/v1")
app.include_router(rol_router.router, prefix="/api/v1", tags=["Roles"])
app.include_router(usuario_agente_router.router, prefix="/api/v1")
app.include_router(departamento_agente_router.router, prefix="/api/v1")
app.include_router(categoria_router.router, prefix="/api/v1", tags=["Categor√≠as"])
app.include_router(unidad_contenido_router.router, prefix="/api/v1")
app.include_router(metrica_diaria_agente_router.router, prefix="/api/v1")
app.include_router(metrica_contenido_router.router, prefix="/api/v1")
app.include_router(agente_virtual_router.router, prefix="/api/v1")
app.include_router(visitante_anonimo_router.router, prefix="/api/v1")
app.include_router(conversacion_sync_router.router, prefix="/api/v1")
app.include_router(chat_router.router, prefix="/api/v1")
app.include_router(chat_auto_router.router, prefix="/api/v1")
app.include_router(agentes_router.router, prefix="/api/v1")
app.include_router(embeddings_router.router, prefix="/api/v1")
app.include_router(persona_router.router, prefix="/api/v1")
app.include_router(usuario_rol_router.router, prefix="/api/v1")
app.include_router(aseguramiento_router.router, prefix="/api/v1")
app.include_router(groq_router.router, prefix="/api/v1")
# Incluir router del widget SIN prefix (acceso directo a /widget y /admin)
app.include_router(widget_router.router, tags=["Widget"])
app.include_router(escalamiento_router.router, prefix="/api/v1")
app.include_router(websocket_router.router)
app.include_router(conversation_router.router)

# ==================== HEALTH CHECK ====================

@app.get("/", tags=["Health"])
@limiter.limit(f"{settings.RATE_LIMIT_PER_MINUTE}/minute")
def root(request: Request):
    """Endpoint ra√≠z con informaci√≥n del sistema"""
    return {
        "message": f"Bienvenido a {settings.APP_NAME}",
        "version": settings.APP_VERSION,
        "status": "running",
        "endpoints": {
            "docs": "/docs",
            "widget": "/widget",
            "admin": "/admin",
            "health": "/health"
        }
    }

@app.get("/health", tags=["Health"])
@limiter.limit(f"{settings.RATE_LIMIT_PER_MINUTE}/minute")
def health_check(request: Request):
    """Verificar estado de la aplicaci√≥n"""
    return {
        "status": "healthy",
        "app": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "database": "connected",
        "groq": {
            "modelo": settings.GROQ_MODEL,
            "disponible": bool(settings.GROQ_API_KEY)
        }
    }

@app.get("/config", tags=["Health"])
@limiter.limit("10/minute")  # L√≠mite m√°s restrictivo para endpoint sensible
def get_config(request: Request):
    """Obtener configuraci√≥n actual (solo disponible en modo DEBUG)"""
    if not settings.DEBUG:
        return JSONResponse(
            status_code=403,
            content={
                "error": "Forbidden",
                "message": "Este endpoint solo est√° disponible en modo DEBUG"
            }
        )
    
    return {
        "app": {
            "name": settings.APP_NAME,
            "version": settings.APP_VERSION,
            "debug": settings.DEBUG
        },
        "database": {
            "host": settings.DB_HOST,
            "port": settings.DB_PORT,
            "name": settings.DB_NAME
        },
        "groq": {
            "modelo": settings.GROQ_MODEL,
            "temperatura": settings.GROQ_TEMPERATURE,
            "max_tokens": settings.GROQ_MAX_TOKENS
        },
        "redis": {
            "host": settings.REDIS_HOST,
            "port": settings.REDIS_PORT
        },
        "chatbot": {
            "name": settings.BOT_NAME,
            "default_agent_id": settings.DEFAULT_AGENT_ID
        }
    }

# ==================== EJECUCI√ìN ====================

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=settings.DEBUG,
        log_level="debug" if settings.DEBUG else "info"
    )
    

from core.security import get_password_hash, verify_password
from database.database import get_db
from sqlalchemy.orm import Session
from fastapi import Depends

@app.get("/dev/generate-hash/{password}")
async def generate_hash_dev(password: str):
    """üîß DESARROLLO: Genera hash de contrase√±a"""
    hashed = get_password_hash(password)
    return {
        "password": password,
        "hash": hashed,
        "sql": f"UPDATE usuario SET password = '{hashed}' WHERE username = 'superadmin';"
    }

@app.get("/dev/check-user/{username}")
async def check_user_dev(username: str, db: Session = Depends(get_db)):
    """üîß DESARROLLO: Verifica usuario"""
    from models.usuario import Usuario
    from models.usuario_rol import UsuarioRol
    from models.rol import Rol
    
    usuario = db.query(Usuario).filter(Usuario.username == username).first()
    
    if not usuario:
        return {"error": f"Usuario '{username}' no encontrado"}
    
    roles = db.query(UsuarioRol).filter(
        UsuarioRol.id_usuario == usuario.id_usuario
    ).join(Rol).all()
    
    return {
        "id_usuario": usuario.id_usuario,
        "username": usuario.username,
        "email": usuario.email,
        "estado": usuario.estado,
        "intentos_fallidos": usuario.intentos_fallidos,
        "password_length": len(usuario.password),
        "roles": [
            {
                "id_rol": r.id_rol,
                "nombre_rol": r.rol.nombre_rol,
                "nivel": r.rol.nivel_jerarquia
            }
            for r in roles
        ]
    }